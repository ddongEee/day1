name: dev-workflow
on:
  push:
    branches: ['*']
defaults:
  run:
    shell: bash

env:
  RUNNABLE_PKG_NAME: "."
  BUILD_FILE_NAME: "build.gradle"
  COMMON_INCLUDES: "gradle.properties, *.gradle, Dockerfile.app.build"
  # Runtime Versions of Applications
  GRADLE_VERSION: "7.5"
  JAVA_VERSION: "11"
  YQ_VERSION: "v4.27.2"
  # Application
  APP_DAY1: day1
  APP_DAY2: day2
  DB_DAY1: db
  MIG_DB_SCHEMA: mig-db-schema
  MIG_DB_DATASET: mig-db-dataset
  # GitOps: Integration target of 'git branches'
  GITOPS_REPO_NAME: day1-appchart

jobs:
  build:
    runs-on: [ HRA-control, dockerd ]
    env:
      ECR_REPO_PREFIX: day1
    steps:
      - name: 🚀 [INIT] Clone repository
        uses: actions/checkout@v3

      # ------------------------------
      # > Set: AWS
      # ------------------------------
      - name: 🚀 [AWS] Assume using IRSA # Ref. https://github.com/aws-actions/configure-aws-credentials#self-hosted-runners
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-region: "ap-northeast-2"
          role-to-assume: "SHARED-EKS-self-hosted-runner" # Federated IAM Role name
          role-session-name: "SHARED-EKS-self-hosted-runner"
          role-duration-seconds: "3600"
          web-identity-token-file: "/var/run/secrets/eks.amazonaws.com/serviceaccount/token"
      
      # ------------------------------
      # > Set: Docker
      # ------------------------------
      - name: 🚀 [SET] Docker - enable chache layer
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-multi-buildx-${{ hashFiles('docker-compose.yml') }}
          restore-keys: |
            ${{ runner.os }}-multi-buildx-

      - name: 🚀 [SET] Docker - check 'docker-compose'
        shell: bash
        run: docker-compose --version

      - name: 🚀 [SET] Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v1

      - name: 🚀 [GRADLE/JVM] Install java
        uses: actions/setup-java@v3
        with:
          distribution: "corretto" # Ref. https://github.com/actions/setup-java#supported-distributions
          java-version: ${{ env.JAVA_VERSION }}
          architecture: x64
          check-latest: true
          cache: 'gradle'

      - name: 🚀 [GRADLE/JVM] Check java
        shell: bash
        run: java --version

      - name: 🚀 [GRADLE/JVM] Pull gradle cache
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('settings.gradle', 'build.gradle', 'gradle/wrapper/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: 🚀 [GRADLE] Check wrapper dependencies
        shell: bash
        run: |
          echo "Generating the Wrapper files requires an installed version of the Gradle runtime on runner"
          chmod +x ./gradlew && ./gradlew wrapper

      - name: 🚀 [BUILD] Build application package
        run: ./gradlew clean build

      - name: 🚀 [BUILD] Build application version check
        id: app-vers
        run: |
          FIRST_GREPPED_APP_VERS=$(cat gradle-ci.properties | grep "appVersion" | tr -d ' ' | head -n 1)
          TRIMMED_APP_VERS=$(echo ${FIRST_GREPPED_APP_VERS} | awk -F '=' '{print $2}')
          echo "> '${FIRST_GREPPED_APP_VERS}' => '${TRIMMED_APP_VERS}'"
          echo "::set-output name=APP_VERS::${TRIMMED_APP_VERS}"

          SHORTEN_SHA=$(git rev-parse --short HEAD)
          echo "> SHORTEN_SHA: ${SHORTEN_SHA}"
          echo "::set-output name=GIT_HASH::${SHORTEN_SHA}"

      - name: 🚀 [BUILD] Build db container image
        id: build-db-container-image
        run: |
          docker-compose build --no-cache \
          --build-arg BASE_REGISTRY=${{ steps.ecr-login.outputs.registry }} db
          
          docker image ls day1_db

      - name: 🚀 [BUILD] Build mig-db-schema container image
        id: build-mig-db-schema-container-image
        run: |
          docker-compose build --parallel \
            --build-arg BASE_REGISTRY=${{ steps.ecr-login.outputs.registry }} mig-db-schema
          
          docker image ls day1_mig

      - name: 🚀 [BUILD] Build mig-db-dataset container image
        id: build-mig-db-dataset-container-image
        run: |
          docker-compose build --parallel \
            --build-arg BASE_REGISTRY=${{ steps.ecr-login.outputs.registry }} mig-db-dataset
          
          docker image ls day1_mig

      - name: 🏃 [RUN] Run & Migrate db container
        id: run-and-mig-db-container
        run: |
          docker-compose up -d db
          docker-compose up mig-db-schema mig-db-dataset
          docker-compose ps -a

      - name: 🚀 [BUILD] Build application container image
        id: build-day1-container-image
        run: |
          docker-compose build --no-cache \
              --build-arg REGISTRY_URL="${{ steps.ecr-login.outputs.registry }}" \
              --build-arg APP_NAME="${{ env.APP_DAY1 }}" \
              --build-arg HASH_TAG="${{ steps.app-vers.outputs.APP_VERS }}" \
              "${{ env.APP_DAY1 }}"

          docker image ls "${{ env.APP_DAY1 }}"

      - name: 🏃 [RUN] Run day1 app
        id: run-app-container
        env:
          TARGET_CONTAINER_PORT: 28081
          # TOTAL_WAIT_TIME = <INITIAL_WAIT> + (<SEQ_MAX_COUNT> * <SCAN_INTERVAL>)
          INITIAL_WAIT: 20 # seconds
          SEQ_MAX_COUNT: 5
          SCAN_INTERVAL: 3 # seconds
        run: |
          docker-compose up -d "${{ env.APP_DAY1 }}"

          echo "" && echo "> Initial wait during ${{ env.INITIAL_WAIT }} seconds."
          sleep ${{ env.INITIAL_WAIT }}

          echo "" && echo "> Done."
          docker-compose ps -a

          echo "-----"
          docker-compose logs "${{ env.APP_DAY1 }}"
          echo "-----"

          echo "" && echo "> Check application container status on ${{ env.SEQ_MAX_COUNT }} times per ${{ env.SCAN_INTERVAL }} seconds."
          for i in `seq ${{ env.SEQ_MAX_COUNT }}`; do
            RES_MSG=$(curl -s http://localhost:${{ env.TARGET_CONTAINER_PORT }}/hello)
            if [ "${RES_MSG}" == "hello" ]; then
              echo "> [PASS] Application is healthy." && exit 0
            fi
            echo "> [WAIT] Retry after ${{ env.SCAN_INTERVAL }} seconds soon.."
            sleep ${{ env.SCAN_INTERVAL }}
          done
          echo "> [FAIL] Time up! Application is finally in unhealthy state. Check this logs."
          docker-compose logs ${{ env.APP_DAY1 }} && exit 1L:

      # TODO: E2E 테스트 실행 환경 구성

      # TODO: E2E 테스트 수행
      
      # TODO: 무관하게 시각화된 레포트 생성 및 업로드

      # TODO: 'main' 브랜치에서만 푸시하도록 조건문 제어
      - name: 🚀 [ECR] Push to ECR repo
        id: push-day1-container-image
        env:
          ecr-repo-url: ${{ steps.ecr-login.outputs.registry }}/${{ env.APP_DAY1 }}
        run: |
          ECR_VERS_TAG="${{ env.ecr-repo-url }}:${{ steps.app-vers.outputs.APP_VERS }}"
          ECR_HASH_TAG="${{ env.ecr-repo-url }}:${{ steps.app-vers.outputs.GIT_HASH }}"
          docker tag ${{ env.APP_DAY1 }}:local ${ECR_VERS_TAG}
          docker tag ${{ env.APP_DAY1 }}:local ${ECR_HASH_TAG}
          docker push ${ECR_VERS_TAG}
          docker push ${ECR_HASH_TAG}
