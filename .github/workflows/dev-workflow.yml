name: dev-workflow
on:
  push:
    branches: ['*']
defaults:
  run:
    shell: bash

env:
  # Monorepo
  RUNNABLE_PKG_NAME: "."
  BUILD_FILE_NAME: "build.gradle"
  COMMON_INCLUDES: "gradle.properties, *.gradle, Dockerfile.app.build"
  # Runtime Versions of Applications
  GRADLE_VERSION: "7.5"
  JAVA_VERSION: "11"
  YQ_VERSION: "v4.27.2"
  # Runtime Versions of Containers
  COMPOSE_VERSION: "v2.9.0"
  BASE_ECR_IMAGE_NAME: day1-base-spring
  BASE_ECR_IMAGE_VERS: "0.1.0"
  # GitOps: Integration target of 'git branches'
  GITOPS_REPO_NAME: k8s-workload

jobs:
  # ===============================================================================
  # *** [ Fecth for matrix: dynamic build job per project (check build needs) ] ***
  # ===============================================================================
  fetch:
    if: ${{ !startsWith(github.ref, 'refs/tags/') }} # branch event (for ACT in local)
    runs-on: [ Linux, X64, HRA-control, dockerd ]
    continue-on-error: false
    steps:
      - name: ðŸš€ [INIT] Clone repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 2

      - name: ðŸš€ [EXTRACT] Get environment variables from repository
        id: env-from-repo
        uses: ./.github/custom-actions/extract/env-from/repository

      - name: ðŸš€ [EXTRACT] Get environment variables from self-hosted runner
        id: env-from-runner
        uses: ./.github/custom-actions/extract/env-from/runner

      - name: ðŸš€ [MATRIX] Find matrix from gradle monorepo
        id: matrix-from-gradle
        uses: ./.github/custom-actions/extract/matrix-from/gradle-monorepo
        with:
          build-gradle-file-name: "${{ env.BUILD_FILE_NAME }}"
          common-includes: "${{ env.COMMON_INCLUDES }}"
          target-projects: "${{ env.RUNNABLE_PKG_NAME }}"

    outputs:
      # EXTRACT: app
      APP_NAME: ${{ steps.env-from-repo.outputs.APP_NAME }}
      APP_VERS: ${{ steps.env-from-repo.outputs.APP_VERS }}
      # EXTRACT: git
      GIT_BRANCH_SHA: ${{ steps.extracted.outputs.GIT_BRANCH_SHA }}
      GIT_BRANCH: ${{ steps.env-from-repo.outputs.GIT_BRANCH }}
      TARGET_GITOPS_BRANCH: ${{ steps.env-from-repo.outputs.TARGET_GITOPS_BRANCH }}
      # EXTRACT: tag
      TIMESTAMP: ${{ steps.env-from-repo.outputs.TIMESTAMP }}
      TIME_TAG: ${{ steps.env-from-repo.outputs.TIME_TAG }}
      HASH_TAG: ${{ steps.env-from-repo.outputs.HASH_TAG }}
      # EXTRACT: runner envir vars
      AWS_REGION: ${{ steps.env-from-runner.outputs.AWS_REGION }}
      FEDERATED_IR_NAME: ${{ steps.env-from-runner.outputs.FEDERATED_IR_NAME }}
      FEDERATED_SA_NAME: ${{ steps.env-from-runner.outputs.FEDERATED_SA_NAME }}
      # MATRIX
      PROJECTS: ${{ steps.matrix-from-gradle.outputs.PROJECTS }}
      TRIMMED_GRADLE_PROJECTS: ${{ steps.matrix-from-gradle.outputs.TRIMMED_PROJECTS }}
      # MATRIX: for Gradle
      HAS_DIFF_GRADLE_PROJECTS: ${{ steps.matrix-from-gradle.outputs.HAS_DIFF_PROJECTS }}
      MATRIX_GRADLE_PROJECT: ${{ steps.matrix-from-gradle.outputs.MATRIX_PROJECT }}

  # ===========================================================
  # *** [ Dynamic build job per project (based on matrix) ] ***
  # ===========================================================
  build:
    needs: [fetch]
    if: ${{ needs.fetch.outputs.HAS_DIFF_GRADLE_PROJECTS }}
    runs-on: [ Linux, X64, HRA-control, dockerd ]
    strategy:
      matrix:
        ${{ fromJSON(needs.fetch.outputs.MATRIX_GRADLE_PROJECT) }}
    env:
      ECR_REPO_PREFIX: ${{ needs.fetch.outputs.APP_NAME }}
    steps:
      - name: ðŸš€ [INIT] Clone repository
        uses: actions/checkout@v3

      - if: ${{ env.ACT }}
        name: ðŸš€ [INIT] Hack environment (for ACT in local running)
        uses: ./.github/custom-actions/set-envir/act-for-local

      # ------------------------------
      # > Set: AWS
      # ------------------------------
      - name: ðŸš€ [SET] AWS CLI with Assuming
        uses: ./.github/custom-actions/set-envir/aws-cli
        with:
          # common
          aws-region: "${{ needs.fetch.outputs.AWS_REGION }}"
          prefix-id: "${{ needs.fetch.outputs.APP_NAME }}-${{ matrix.project }}"
          unique-id: "${{ needs.fetch.outputs.GIT_BRANCH_SHA }}-runner-${{ github.run_number }}"
          # for ACT in local running
          act-role-arn: "${{ env.AWS_ROLE_ARN }}"
          act-session-name: "${{ env.AWS_ROLE_SESSION_NAME }}"
          # for self-hosted runner in EKS
          federated-role-name: "${{ needs.fetch.outputs.FEDERATED_IR_NAME }}"

      # ------------------------------
      # > Set: Docker
      # ------------------------------
      - name: ðŸš€ [SET] Docker CLI
        uses: ./.github/custom-actions/set-envir/docker-cli
        env:
          install-compose: "true"

      - if: ${{ !env.ACT }}
        name: ðŸš€ [SET] Install 'docker-compose'
        shell: bash
        run: |
          sudo curl -fsSL "https://github.com/docker/compose/releases/download/${{ env.COMPOSE_VERSION }}/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          sudo chown runner:root /usr/local/bin/docker-compose
          sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose
          docker-compose --version

      - name: ðŸš€ [SET] Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v1

      # ------------------------------
      # > Set: Gradle
      # ------------------------------
      - name: ðŸš€ [SET] Gradle on JVM
        uses: ./.github/custom-actions/set-envir/gradle
        with:
          set-gradle-version: "${{ env.GRADLE_VERSION }}"
          set-java-distribution: "corretto"
          set-java-version: "${{ env.JAVA_VERSION }}"

      # ------------------------------
      # > BUILD + STATIC TEST(TODO)
      # ------------------------------
      - if: ${{ !env.ACT }} # To avoid hang on ACT in local
        name: ðŸš€ [BUILD] Validate wrapper
        uses: gradle/wrapper-validation-action@v1

      - name: ðŸš€ [BUILD] Build application package (include UnitTest, etc)
        run: ./gradlew ${{ matrix.project }}:build

      - name: ðŸš€ [BUILD] Build application container image
        id: build-container-image
        run: |
          docker-compose build --no-cache \
              --build-arg REGISTRY_URL="${{ steps.ecr-login.outputs.registry }}/" \
              --build-arg BASE_IMG_NAME="${{ env.BASE_ECR_IMAGE_NAME }}" \
              --build-arg BASE_IMG_VERS="${{ env.BASE_ECR_IMAGE_VERS }}" \
              --build-arg APP_NAME="${{ matrix.project }}" \
              --build-arg HASH_TAG="${{ needs.fetch.outputs.HASH_TAG }}" \
              ${{ matrix.project }}

          docker image ls ${{ matrix.project }}

      # ------------------------------
      # > SSOT - ECR
      # ------------------------------
      - if: ${{ github.event_name == 'push' }}
        name: ðŸš€ [SSOT/ECR] Check branch can push container image to ECR repository - allow only 'push' event
        id: can-push-to-ecr
        run: |
          isRelease=${{ needs.fetch.outputs.GIT_BRANCH == 'release' }}
          isMain=${{ needs.fetch.outputs.GIT_BRANCH == 'main' }}
          cat <<EOF
          ðŸ”Ž isRelease: ${isRelease}
          ðŸ”Ž isMain: ${isMain}
          EOF
          if  [ ${isRelease} == 'true' ] || \
              [ ${isMain} == 'true' ] || \
              [ ${{ env.ACT }} ]; then
              echo "::set-output name=can-push::true"
          fi

      - if: ${{ steps.can-push-to-ecr.outputs.can-push }}
        name: ðŸš€ [SSOT/ECR] Tagging
        id: tag-container-image
        env:
          ecr-repo-url: ${{ steps.ecr-login.outputs.registry }}/${{ env.ECR_REPO_PREFIX }}/${{ matrix.project }}
        run: |
          ECR_HASH_TAG="${{ env.ecr-repo-url }}:${{ needs.fetch.outputs.HASH_TAG }}"
          ECR_TIME_TAG="${{ env.ecr-repo-url }}:${{ needs.fetch.outputs.TIME_TAG }}"
          cat <<EOF
          ðŸ”Ž ECR_HASH_TAG : ${ECR_HASH_TAG}
          ðŸ”Ž ECR_TIME_TAG : ${ECR_TIME_TAG}
          EOF
          docker tag ${{ matrix.project }}:local ${ECR_HASH_TAG}
          docker tag ${{ matrix.project }}:local ${ECR_TIME_TAG}
          docker image ls ${{ env.ecr-repo-url }}

          echo "::set-output name=ECR_HASH_TAG::${ECR_HASH_TAG}"
          echo "::set-output name=ECR_TIME_TAG::${ECR_TIME_TAG}"

      - if: ${{ steps.can-push-to-ecr.outputs.can-push }}
        name: ðŸš€ [SSOT/ECR] Remove duplicated HASH-TAG
        uses: ./.github/custom-actions/check/tag-duplication-in-ecr
        with:
          ecr-repo-prefix: ${{ env.ECR_REPO_PREFIX }}
          trimmed-target-projects: ${{ matrix.project }}
          target-image-tag: ${{ needs.fetch.outputs.HASH_TAG }}
          remove-if-duplicated: "true"

      - if: ${{ steps.can-push-to-ecr.outputs.can-push }}
        id: push-container-image
        name: ðŸš€ [SSOT/ECR] Push to ECR repo
        run: |
          docker push ${{ steps.tag-container-image.outputs.ECR_HASH_TAG }} && sleep 5
          docker push ${{ steps.tag-container-image.outputs.ECR_TIME_TAG }}

      # ------------------------------
      # > CLEAN-UP
      # ------------------------------
      - if: ${{ env.ACT && steps.push-container-image.outcome == 'success' }}
        name: ðŸš€ [CLEAN-UP] Remove uploaded hash-tag (built from ACT)
        uses: ./.github/custom-actions/check/tag-duplication-in-ecr
        with:
          ecr-repo-prefix: ${{ env.ECR_REPO_PREFIX }}
          trimmed-target-projects: ${{ matrix.project }}
          target-image-tag: ${{ needs.fetch.outputs.HASH_TAG }}
          remove-if-duplicated: "true"

      - if: ${{ env.ACT && steps.push-container-image.outcome == 'success' }}
        name: ðŸš€ [CLEAN-UP] Remove uploaded time-tag (built from ACT)
        uses: ./.github/custom-actions/check/tag-duplication-in-ecr
        with:
          ecr-repo-prefix: ${{ env.ECR_REPO_PREFIX }}
          trimmed-target-projects: ${{ matrix.project }}
          target-image-tag: ${{ needs.fetch.outputs.TIME_TAG }}
          remove-if-duplicated: "true"

      - if: ${{ always() && steps.tag-container-image.outcome == 'success' }}
        name: ðŸš€ [CLEAN-UP] Remove local tagged images
        continue-on-error: true
        run: |
          docker rmi ${{ steps.tag-container-image.outputs.ECR_HASH_TAG }} 2&1> /dev/null
          docker rmi ${{ steps.tag-container-image.outputs.ECR_TIME_TAG }} 2&1> /dev/null
          docker rmi ${{ matrix.project }}:local 2&1> /dev/null

      - if: ${{ failure() }}
        name: ðŸš€ [CLEAN-UP] Remove local untagged images
        run: docker rmi $(docker images -f "dangling=true" -q) 2&1> /dev/null

  # ==========================
  # *** [ Push to GitOps ] ***
  # ==========================
  # TODO: Refactor similar step with 'ci-tag-for-align/align-gitops'
  push-to-gitops:
    needs: [fetch, build]
    if: ${{ startsWith(github.ref, 'refs/heads/release/') }}
    runs-on: [ Linux, X64, HRA-control, dockerd ]
    env:
      gitops-path: ./gitops
    steps:
      - name: ðŸš€ [INIT] Clone this repository
        uses: actions/checkout@v3

      - name: ðŸš€ [INIT] Clone GitOps repository
        uses: actions/checkout@v3
        with:
          path: ${{ env.gitops-path }}
          repository: ${{ github.repository_owner }}/${{ env.GITOPS_REPO_NAME }}
          ref: ${{ needs.fetch.outputs.TARGET_GITOPS_BRANCH }}
          token: ${{ secrets.SA_DEPLOY_GIT_PAT }}

      # ------------------------------
      # > PREPARE
      # ------------------------------
      - name: ðŸš€ [PREPARE] Install YQ
        run: |
          sudo wget -q https://github.com/mikefarah/yq/releases/download/${{ env.YQ_VERSION }}/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq
          yq --version

      - name: ðŸš€ [PREPARE] Grep target
        id: get-target-projects
        run: |
          [[ $(echo ${{ needs.fetch.outputs.TRIMMED_GRADLE_PROJECTS }} | grep "student" | wc -l | tr -d ' ') > 0 ]] \
              && echo "::set-output name=HAS_STUDENT::true"
          [[ $(echo ${{ needs.fetch.outputs.TRIMMED_GRADLE_PROJECTS }} | grep "teacher" | wc -l | tr -d ' ') > 0 ]] \
              && echo "::set-output name=HAS_TEACHER::true"

      - name: ðŸš€ [PREPARE] Set chart directory
        id: set-chart-directory
        run: |
          GITOPS_CHART_DIR="${{ env.gitops-path }}/app-chart/${{ needs.fetch.outputs.APP_NAME }}"
          cat <<EOF
          ðŸ”Ž GITOPS_CHART_DIR : ${GITOPS_CHART_DIR}
          EOF
          echo "::set-output name=GITOPS_CHART_DIR::${GITOPS_CHART_DIR}"

      # ------------------------------
      # > CONFIG : BASIC
      # ------------------------------
      - name: ðŸš€ [CONFIG/BASIC] Generate default configuration schema
        run: |
          for project in ${{ needs.fetch.outputs.TRIMMED_GRADLE_PROJECTS }}; do
              cd ./${project}/src/main/resources/
              cp application.yaml application-ci.yaml
              yq eval -i '(.server.port = "${SERVER_PORT}")' application-ci.yaml
              yq eval -i '(.management.server.port = "${ACTUATOR_PORT}")' application-ci.yaml

              echo "ðŸ”Ž [Edit commonly] at application-ci.yaml"
              cat application-ci.yaml | egrep "SERVER_PORT|ACTUATOR_PORT"
              echo ""
              cd -
          done

      # ------------------------------
      # > CONFIG : PER PROJECT
      # ------------------------------
      - if: ${{ steps.get-target-projects.outputs.HAS_STUDENT == 'true' }}
        name: ðŸš€ [CONFIG/PER-PROJECT] Edit '${{ env.project-name }}' configuration schema
        env:
          project-name: student
        run: |
          SELECTED_SCHEMA="./${{ env.project-name }}/src/main/resources/application-ci.yaml"
          yq eval -i '(.somthing.key1 = "${STH_VALUE1}")' ${SELECTED_SCHEMA}
          yq eval -i '(.somthing.key2 = "${STH_VALUE2}")' ${SELECTED_SCHEMA}
          yq eval -i '(.somthing.key3 = "${STH_VALUE3}")' ${SELECTED_SCHEMA}

          echo "ðŸ”Ž [Edit per project] at ${SELECTED_SCHEMA}"
          cat ${SELECTED_SCHEMA}

      - if: ${{ steps.get-target-projects.outputs.HAS_TEACHER == 'true' }}
        name: ðŸš€ [CONFIG/PER-PROJECT] Edit '${{ env.project-name }}' configuration schema
        env:
          project-name: teacher
        run: |
          SELECTED_SCHEMA="./${{ env.project-name }}/src/main/resources/application-ci.yaml"
          yq eval -i '(.other-thing.key1 = "${OTHER_VALUE1}")' ${SELECTED_SCHEMA}
          yq eval -i '(.other-thing.key2 = "${OTHER_VALUE2}")' ${SELECTED_SCHEMA}
          yq eval -i '(.other-thing.key3 = "${OTHER_VALUE3}")' ${SELECTED_SCHEMA}

          echo "ðŸ”Ž [Edit per project] at ${SELECTED_SCHEMA}"
          cat ${SELECTED_SCHEMA}

      # ------------------------------
      # > SSOT: Write down config
      # ------------------------------
      - name: ðŸš€ [SSOT/CONFIG] Generate default configuration schema
        run: |
          for project in ${{ needs.fetch.outputs.TRIMMED_GRADLE_PROJECTS }}; do
              schema="./${project}/src/main/resources/application-ci.yaml"
              target_path="${{ steps.set-chart-directory.outputs.GITOPS_CHART_DIR }}/${project}/configs/application.yaml"
              cat <<EOF
          ðŸ”Ž project      : ${project}
          ðŸ”Ž schema       : ${schema}
          ðŸ”Ž target_path  : ${target_path}
          EOF
              cp ${schema} ${target_path}
              echo "ðŸ”Ž [Written config schema / ${project}] Copied! ${target_path}"
              echo ""
          done

      # ------------------------------
      # > SSOT: Write down values
      # ------------------------------
      - name: ðŸš€ [SSOT/TAG] Update 'image tag(${{ needs.fetch.outputs.TIME_TAG }})' with 'comment(${{ needs.fetch.outputs.HASH_TAG }})'
        uses: ./.github/custom-actions/replace/image-tag-in-charts
        with:
          monorepo-charts-path: ${{ steps.set-chart-directory.outputs.GITOPS_CHART_DIR }}
          trimmed-projects: ${{ needs.fetch.outputs.TRIMMED_GRADLE_PROJECTS }}
          target-gitops-branch: ${{ needs.fetch.outputs.TARGET_GITOPS_BRANCH }}
          human-readable-image-tag: ${{ needs.fetch.outputs.TIME_TAG }}
          git-hash-tag-for-comment: ${{ needs.fetch.outputs.HASH_TAG }}

      - if: ${{ !env.ACT }}
        name: ðŸš€ [SSOT/PUSH] Push commit to GitOps Repository
        uses: cpina/github-action-push-to-another-repository@v1.5
        env:
          API_TOKEN_GITHUB: ${{ secrets.SA_DEPLOY_GIT_PAT }}
        with:
          # Source Setting
          source-directory: ${{ env.gitops-path }}
          # Target Setting
          destination-github-username: ${{ github.repository_owner }}
          destination-repository-name: ${{ env.GITOPS_REPO_NAME }}
          target-branch: ${{ needs.fetch.outputs.TARGET_GITOPS_BRANCH }}
          # Commit Setting
          user-email: "github-actions@github.com"
          user-name: "github-actions"

  # ==========================================
  # *** [ Push RC(release candidate) Tag ] ***
  # ==========================================
  push-rc-tag:
    needs: [fetch, build]
    if: ${{ github.ref == 'refs/heads/main' }}
    runs-on: [ Linux, X64, HRA-control, dockerd ]
    env:
      SEM_VERS: "v${{ needs.fetch.outputs.APP_VERS }}"
    steps:
      - name: ðŸš€ [INIT] Clone this repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.SA_DEPLOY_GIT_PAT }}

      - name: ðŸš€ [INIT] Git committer setting with PAT
        run: |
          git config --global user.email "github-actions@github.com"
          git config --global user.name "github-actions"
          git remote -v

      # ------------------------------
      # > TAG
      # ------------------------------
      - name: ðŸš€ [TAG] Get next release candidate number
        id: rc-tag
        uses: ./.github/custom-actions/check/tag-rc-number-in-repository
        with:
          semantic-version: "${{ env.SEM_VERS }}"

      - name: ðŸš€ [TAG] Create a new tag named with 'next release candidate number', then push
        env:
          NEXT_RC: "${{ env.SEM_VERS }}_rc${{ steps.rc-tag.outputs.NEXT_RC_NUM }}"
        run: |
          git tag -a ${{ env.NEXT_RC }} -m "Auto created release candidate of '${{ env.SEM_VERS }}' at '${{ needs.fetch.outputs.TIMESTAMP }}'"
          NEW_TAG_COUNT=$(git tag --list | grep "${{ env.NEXT_RC }}" | wc -l)
          [[ ${NEW_TAG_COUNT} = 0 ]] && {
              >&2 echo "ðŸ”Ž Cannot find out new release candidate: ${{ env.NEXT_RC }}"
              exit 1
          }
          echo "ðŸ”Ž Tagged new release candidate: ${{ env.NEXT_RC }}"
          git show ${{ env.NEXT_RC }}

          echo "ðŸ”Ž Try to push"
          git push origin ${{ env.NEXT_RC }}

