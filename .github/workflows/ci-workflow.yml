name: CI workflow
on:
  push:
    branches: ['*']
defaults:
  run:
    shell: bash

env:
  RUNNABLE_PKG_NAME: "."
  BUILD_FILE_NAME: "build.gradle"
  COMMON_INCLUDES: "gradle.properties, *.gradle, Dockerfile.app.build"
  # Runtime Versions of Applications
  GRADLE_VERSION: "7.5"
  JAVA_VERSION: "11"
  YQ_VERSION: "v4.27.2"
  # Application
  APP_DAY1: day1
  APP_DAY2: day2
  DB_DAY1: db
  MIG_DB_SCHEMA: mig-db-schema
  MIG_DB_DATASET: mig-db-dataset
  # GitOps: Integration target of 'git branches'
  GITOPS_REPO_NAME: day1-appchart

jobs:
  build:
    runs-on: [ self-hosted, HRA-control, dockerd ]
    env:
      ECR_REPO_PREFIX: day1
    steps:
      - name: 🚀 [INIT] Clone repository
        uses: actions/checkout@v3

      # ------------------------------
      # > Set: AWS
      # ------------------------------
      - name: 🚀 [AWS] Assume using IRSA # Ref. https://github.com/aws-actions/configure-aws-credentials#self-hosted-runners
        uses: aws-actions/configure-aws-credentials@v1-node16
        with:
          aws-region: "ap-northeast-2"
          role-to-assume: "SHARED-EKS-self-hosted-runner" # Federated IAM Role name
          role-session-name: "SHARED-EKS-self-hosted-runner"
          role-duration-seconds: "3600"
          web-identity-token-file: "/var/run/secrets/eks.amazonaws.com/serviceaccount/token"
      
      # ------------------------------
      # > Set: Docker
      # ------------------------------
      - name: 🚀 [SET] Docker - enable chache layer
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-multi-buildx-${{ hashFiles('docker-compose.yml') }}
          restore-keys: |
            ${{ runner.os }}-multi-buildx-

      - name: 🚀 [SET] Docker - check 'docker-compose'
        shell: bash
        run: docker-compose --version

      - name: 🚀 [SET] Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v1

      - name: 🚀 [GRADLE/JVM] Install java
        uses: actions/setup-java@v3
        with:
          distribution: "corretto" # Ref. https://github.com/actions/setup-java#supported-distributions
          java-version: ${{ env.JAVA_VERSION }}
          architecture: x64
          check-latest: true
          cache: 'gradle'

      - name: 🚀 [GRADLE/JVM] Check java
        shell: bash
        run: java --version

      - name: 🚀 [GRADLE/JVM] Pull gradle cache
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('settings.gradle', 'build.gradle', 'gradle/wrapper/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: 🚀 [GRADLE] Check wrapper dependencies
        shell: bash
        run: |
          echo "Generating the Wrapper files requires an installed version of the Gradle runtime on runner"
          chmod +x ./gradlew && ./gradlew wrapper

      - name: 🚀 [BUILD] Build application package
        run: ./gradlew clean build

      - name: 🚀 [BUILD] Build application version check
        id: app-vers
        run: |
          FIRST_GREPPED_APP_VERS=$(cat gradle-ci.properties | grep "appVersion" | tr -d ' ' | head -n 1)
          TRIMMED_APP_VERS=$(echo ${FIRST_GREPPED_APP_VERS} | awk -F '=' '{print $2}')
          echo "> APP_VERS: '${FIRST_GREPPED_APP_VERS}' => '${TRIMMED_APP_VERS}'"
          # Set output
          echo "APP_VERS=${TRIMMED_APP_VERS}" >> $GITHUB_OUTPUT

          SHORTEN_SHA=$(git rev-parse --short HEAD)
          echo "> SHORTEN_SHA: ${SHORTEN_SHA}"
          # Set output
          echo "GIT_HASH=${SHORTEN_SHA}" >> $GITHUB_OUTPUT

      - name: 🚀 [BUILD] Build db container image
        run: |
          docker-compose build --no-cache \
              --build-arg BASE_REGISTRY=${{ steps.ecr-login.outputs.registry }} \
              db
          docker image ls day1_db

      - name: 🚀 [BUILD] Build mig-db-schema container image
        run: |
          docker-compose build --parallel \
              --build-arg BASE_REGISTRY=${{ steps.ecr-login.outputs.registry }} \
              mig-db-schema
          docker image ls day1_mig

      - name: 🚀 [BUILD] Build mig-db-dataset container image
        run: |
          docker-compose build --parallel \
              --build-arg BASE_REGISTRY=${{ steps.ecr-login.outputs.registry }} \
              mig-db-dataset
          docker image ls day1_mig

      - name: 🏃 [RUN] Run & Migrate db container
        run: |
          docker-compose up -d db
          docker-compose run mig-db-schema
          docker-compose run mig-db-dataset
          docker-compose ps -a

      - name: 🚀 [BUILD] Build application container image
        id: build-day1-container-image
        run: |
          docker-compose build --no-cache \
              --build-arg REGISTRY_URL="${{ steps.ecr-login.outputs.registry }}" \
              --build-arg APP_NAME="${{ env.APP_DAY1 }}" \
              --build-arg HASH_TAG="${{ steps.app-vers.outputs.APP_VERS }}" \
              "${{ env.APP_DAY1 }}"
          docker image ls "${{ env.APP_DAY1 }}"

      - name: 🏃 [RUN] Run day1 app
        id: run-app-container
        env:
          TARGET_CONTAINER_PORT: 28081
          # TOTAL_WAIT_TIME = <INITIAL_WAIT> + (<SEQ_MAX_COUNT> * <SCAN_INTERVAL>)
          INITIAL_WAIT: 20 # seconds
          SEQ_MAX_COUNT: 5
          SCAN_INTERVAL: 3 # seconds
        run: |
          docker-compose up -d "${{ env.APP_DAY1 }}"

          echo "" && echo "> Initial wait during ${{ env.INITIAL_WAIT }} seconds."
          sleep ${{ env.INITIAL_WAIT }}

          echo "" && echo "> Done."
          docker-compose ps -a

          echo "-----"
          docker-compose logs "${{ env.APP_DAY1 }}"
          echo "-----"

          echo "" && echo "> Check application container status on ${{ env.SEQ_MAX_COUNT }} times per ${{ env.SCAN_INTERVAL }} seconds."
          for i in `seq ${{ env.SEQ_MAX_COUNT }}`; do
            RES_MSG=$(curl -s http://localhost:${{ env.TARGET_CONTAINER_PORT }}/hello)
            if [ "${RES_MSG}" == "hello" ]; then
              echo "> [PASS] Application is healthy." && exit 0
            fi
            echo "> [WAIT] Retry after ${{ env.SCAN_INTERVAL }} seconds soon.."
            sleep ${{ env.SCAN_INTERVAL }}
          done
          echo "> [FAIL] Time up! Application is finally in unhealthy state. Check this logs."
          docker-compose logs ${{ env.APP_DAY1 }} && exit 1L:

      - name: 🚀 [BUILD] Build end-to-end test container image
        run: |
          docker-compose build --no-cache \
              --build-arg REGISTRY_URL="${{ steps.ecr-login.outputs.registry }}" \
              e2e

          docker image ls "${{ env.APP_DAY1 }}_e2e"

      - name: 🏃 [RUN] BDD-REST > End-to-end test
        continue-on-error: true
        env:
          TARGET_CONTAINER_PORT: 28081
          TEST_RESULT_DATA_PATH: ./build-src/system-behavior/outputs/mounts/basic
        run: |
          echo "> Permission setting for alpine docker image on volume mounting"
          mkdir -p  ${{ env.TEST_RESULT_DATA_PATH }}
          chmod 777 ${{ env.TEST_RESULT_DATA_PATH }}
          
          SYSTEM_PORT=${{ env.TARGET_CONTAINER_PORT }}
          SYSTEM_VERSION="${{ steps.app-vers.outputs.APP_VERS }} (commit hash: ${{ steps.app-vers.outputs.GIT_HASH }})"
          SYSTEM_RUNTIME="'docker' in docker-compose / on actions-runner pod"
          docker-compose run e2e

          echo "" && echo "> Result raw files..."
          echo "--------------------------------"
          ls -ahl ${{ env.TEST_RESULT_DATA_PATH }}
      
      # Export: Upload BDD Report
      # -----------------------------------------
      - if: ${{ always() }}
        name: 🚀 [EXPORT] BDD-REST > Visualized Report
        continue-on-error: true
        env:
          TEST_RESULT_HTML_PATH: ./build-src/system-behavior/outputs/mounts/report
        run: |
          echo "> Permission setting for alpine docker image on volume mounting"
          mkdir -p  ${{ env.TEST_RESULT_HTML_PATH }}
          chmod 777 ${{ env.TEST_RESULT_HTML_PATH }}
          
          docker-compose run e2e-report

          echo "" && echo "> Generated HTML Report"
          echo "----------------------------------"
          ls -ahl ${{ env.TEST_RESULT_HTML_PATH }}

      - if: ${{ always() }}
        name: 🚀 [EXPORT] BDD-REST > Visualized Report > Upload Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: system-behavior-report
          path: ./build-src/system-behavior/outputs/mounts/report

      # TODO: 'main' 브랜치에서만 푸시하도록 조건문 제어
      - name: 🚀 [ECR] Push to ECR repo
        id: push-day1-container-image
        env:
          ecr-repo-url: ${{ steps.ecr-login.outputs.registry }}/${{ env.APP_DAY1 }}
        run: |
          ALPHA_VERS_TAG="${{ steps.app-vers.outputs.APP_VERS }}-alpha"
          ALPHA_HASH_TAG="${ALPHA_VERS_TAG}-${{ steps.app-vers.outputs.GIT_HASH }}"
          
          ECR_VERS_TAG="${{ env.ecr-repo-url }}:${ALPHA_VERS_TAG}"
          ECR_HASH_TAG="${{ env.ecr-repo-url }}:${ALPHA_HASH_TAG}"

          docker tag ${{ env.APP_DAY1 }}:local ${ECR_VERS_TAG}
          docker tag ${{ env.APP_DAY1 }}:local ${ECR_HASH_TAG}

          docker push ${ECR_VERS_TAG}
          docker push ${ECR_HASH_TAG}

      # TODO: AWS SecretManager에서 PAT 불러오기
      # TODO: 'main' 브랜치에서만 푸시하도록 조건문 제어

      # TODO: application.yml 파일 복사
      # TODO: 'main' 브랜치에서만 푸시하도록 조건문 제어

      # TODO: release.yml 파일에 이미지 태그 갱신 로직 추가 > X.Y.Z-alpha-HASH
      # TODO: 'main' 브랜치에서만 푸시하도록 조건문 제어

      # TODO: push-to-another-repository 수행
      # TODO: 'main' 브랜치에서만 푸시하도록 조건문 제어
